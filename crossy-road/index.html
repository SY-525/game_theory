<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crossy Road - Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }

        h1 {
            color: white;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #gameCanvas {
            border: 4px solid white;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            background: #87CEEB;
            display: block;
            margin: 20px auto;
        }

        #score {
            color: white;
            font-size: 1.5em;
            margin: 10px 0;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        #gameOver {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            z-index: 10;
        }

        #gameOver h2 {
            font-size: 3em;
            margin-bottom: 20px;
            color: #ff4444;
        }

        #gameOver p {
            font-size: 1.5em;
            margin-bottom: 20px;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2em;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(0, 0, 0, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        #instructions {
            color: white;
            font-size: 1em;
            margin-top: 15px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        #instructions p {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <h1>üêî Crossy Road</h1>
        <div id="score">Score: 0 | Best: 0</div>
        <canvas id="gameCanvas" width="600" height="700"></canvas>
        <div id="instructions">
            <p><strong>Controls:</strong> Arrow Keys or WASD to move</p>
            <p>üöó Avoid cars | üåä Jump on logs | üèÜ Go as far as you can!</p>
        </div>
    </div>

    <div id="gameOver">
        <h2>Game Over!</h2>
        <p id="finalScore">Score: 0</p>
        <button onclick="game.restart()">Play Again</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game constants
        const GRID_SIZE = 50;
        const CANVAS_WIDTH = canvas.width;
        const CANVAS_HEIGHT = canvas.height;
        const GRID_COLS = CANVAS_WIDTH / GRID_SIZE;
        const GRID_ROWS = CANVAS_HEIGHT / GRID_SIZE;

        // Lane types
        const LANE_TYPES = {
            GRASS: 'grass',
            ROAD: 'road',
            RIVER: 'river'
        };

        // Player class
        class Player {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = Math.floor(GRID_COLS / 2);
                this.y = GRID_ROWS - 2;
                this.targetX = this.x;
                this.targetY = this.y;
                this.moving = false;
                this.moveProgress = 0;
                this.maxScore = 0;
            }

            move(dx, dy) {
                if (this.moving) return;

                const newX = this.x + dx;
                const newY = this.y + dy;

                if (newX >= 0 && newX < GRID_COLS && newY >= 0 && newY < GRID_ROWS) {
                    this.targetX = newX;
                    this.targetY = newY;
                    this.moving = true;
                    this.moveProgress = 0;

                    // Update score when moving forward
                    if (dy < 0) {
                        const newScore = GRID_ROWS - this.targetY - 2;
                        if (newScore > game.score) {
                            game.score = newScore;
                            game.maxScore = Math.max(game.maxScore, game.score);
                        }
                    }
                }
            }

            update() {
                if (this.moving) {
                    this.moveProgress += 0.15;
                    if (this.moveProgress >= 1) {
                        this.x = this.targetX;
                        this.y = this.targetY;
                        this.moving = false;
                        this.moveProgress = 0;
                    }
                }
            }

            draw() {
                const renderX = this.moving
                    ? this.x + (this.targetX - this.x) * this.moveProgress
                    : this.x;
                const renderY = this.moving
                    ? this.y + (this.targetY - this.y) * this.moveProgress
                    : this.y;

                const screenX = renderX * GRID_SIZE;
                const screenY = renderY * GRID_SIZE;

                // Draw chicken character
                ctx.save();

                // Body
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(screenX + 10, screenY + 20, 30, 25);

                // Head
                ctx.fillStyle = '#FFE44D';
                ctx.fillRect(screenX + 15, screenY + 10, 20, 15);

                // Beak
                ctx.fillStyle = '#FF6B35';
                ctx.fillRect(screenX + 20, screenY + 15, 8, 5);

                // Eyes
                ctx.fillStyle = '#000';
                ctx.fillRect(screenX + 20, screenY + 12, 3, 3);
                ctx.fillRect(screenX + 27, screenY + 12, 3, 3);

                // Comb
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(screenX + 22, screenY + 8, 6, 4);

                // Feet
                ctx.fillStyle = '#FF6B35';
                ctx.fillRect(screenX + 15, screenY + 43, 6, 4);
                ctx.fillRect(screenX + 29, screenY + 43, 6, 4);

                ctx.restore();
            }

            getPosition() {
                return {
                    x: this.moving ? this.targetX : this.x,
                    y: this.moving ? this.targetY : this.y
                };
            }
        }

        // Obstacle class
        class Obstacle {
            constructor(lane, x, speed, type) {
                this.lane = lane;
                this.x = x;
                this.speed = speed;
                this.type = type;
                this.width = type === 'log' ? 2 : 1;
            }

            update() {
                this.x += this.speed;

                // Wrap around
                if (this.speed > 0 && this.x > GRID_COLS + 2) {
                    this.x = -this.width - 2;
                } else if (this.speed < 0 && this.x < -this.width - 2) {
                    this.x = GRID_COLS + 2;
                }
            }

            draw() {
                const screenX = this.x * GRID_SIZE;
                const screenY = this.lane.y * GRID_SIZE;

                if (this.type === 'car') {
                    // Car
                    ctx.fillStyle = this.speed > 0 ? '#FF4444' : '#4444FF';
                    ctx.fillRect(screenX + 5, screenY + 10, GRID_SIZE - 10, 30);

                    // Windows
                    ctx.fillStyle = '#87CEEB';
                    ctx.fillRect(screenX + 12, screenY + 15, 15, 10);
                    ctx.fillRect(screenX + 30, screenY + 15, 10, 10);

                    // Wheels
                    ctx.fillStyle = '#333';
                    ctx.fillRect(screenX + 8, screenY + 8, 8, 6);
                    ctx.fillRect(screenX + 8, screenY + 36, 8, 6);
                    ctx.fillRect(screenX + 34, screenY + 8, 8, 6);
                    ctx.fillRect(screenX + 34, screenY + 36, 8, 6);
                } else if (this.type === 'log') {
                    // Log
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(screenX, screenY + 10, this.width * GRID_SIZE, 30);

                    // Wood texture
                    ctx.fillStyle = '#654321';
                    for (let i = 0; i < this.width * 2; i++) {
                        ctx.fillRect(screenX + i * 25, screenY + 20, 3, 10);
                    }
                }
            }

            collidesWith(x, y) {
                return y === this.lane.y &&
                       x >= Math.floor(this.x) &&
                       x < Math.floor(this.x) + this.width;
            }
        }

        // Lane class
        class Lane {
            constructor(y, type) {
                this.y = y;
                this.type = type;
                this.obstacles = [];
                this.color = this.getColor();

                if (type === LANE_TYPES.ROAD) {
                    this.initRoad();
                } else if (type === LANE_TYPES.RIVER) {
                    this.initRiver();
                }
            }

            getColor() {
                switch (this.type) {
                    case LANE_TYPES.GRASS:
                        return '#90EE90';
                    case LANE_TYPES.ROAD:
                        return '#444444';
                    case LANE_TYPES.RIVER:
                        return '#4169E1';
                    default:
                        return '#90EE90';
                }
            }

            initRoad() {
                const direction = Math.random() > 0.5 ? 1 : -1;
                const speed = (Math.random() * 0.03 + 0.02) * direction;
                const spacing = 3 + Math.random() * 3;

                for (let i = 0; i < GRID_COLS; i += spacing) {
                    const x = direction > 0 ? i : GRID_COLS - i;
                    this.obstacles.push(new Obstacle(this, x, speed, 'car'));
                }
            }

            initRiver() {
                const direction = Math.random() > 0.5 ? 1 : -1;
                const speed = (Math.random() * 0.02 + 0.015) * direction;
                const spacing = 4 + Math.random() * 2;

                for (let i = 0; i < GRID_COLS; i += spacing) {
                    const x = direction > 0 ? i : GRID_COLS - i;
                    this.obstacles.push(new Obstacle(this, x, speed, 'log'));
                }
            }

            update() {
                this.obstacles.forEach(obstacle => obstacle.update());
            }

            draw() {
                // Draw lane background
                ctx.fillStyle = this.color;
                ctx.fillRect(0, this.y * GRID_SIZE, CANVAS_WIDTH, GRID_SIZE);

                // Draw road markings
                if (this.type === LANE_TYPES.ROAD) {
                    ctx.fillStyle = '#FFFF00';
                    for (let i = 0; i < GRID_COLS; i++) {
                        ctx.fillRect(i * GRID_SIZE + 20, this.y * GRID_SIZE + 23, 10, 4);
                    }
                }

                // Draw river waves
                if (this.type === LANE_TYPES.RIVER) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    for (let i = 0; i < GRID_COLS * 2; i++) {
                        const offset = Math.sin(Date.now() * 0.002 + i * 0.5) * 3;
                        ctx.fillRect(i * 15, this.y * GRID_SIZE + 15 + offset, 8, 3);
                    }
                }

                // Draw obstacles
                this.obstacles.forEach(obstacle => obstacle.draw());
            }
        }

        // Game class
        class Game {
            constructor() {
                this.player = new Player();
                this.lanes = [];
                this.score = 0;
                this.maxScore = 0;
                this.gameOver = false;
                this.keys = {};
                this.lastMoveTime = 0;
                this.moveDelay = 150;

                this.init();
                this.setupControls();
                this.gameLoop();
            }

            init() {
                this.lanes = [];

                // Create lanes
                for (let y = 0; y < GRID_ROWS; y++) {
                    let type;
                    if (y === GRID_ROWS - 1 || y === GRID_ROWS - 2) {
                        type = LANE_TYPES.GRASS; // Safe starting zone
                    } else {
                        const rand = Math.random();
                        if (rand < 0.3) {
                            type = LANE_TYPES.GRASS;
                        } else if (rand < 0.65) {
                            type = LANE_TYPES.ROAD;
                        } else {
                            type = LANE_TYPES.RIVER;
                        }
                    }
                    this.lanes.push(new Lane(y, type));
                }
            }

            setupControls() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;

                    if (this.gameOver) return;

                    const now = Date.now();
                    if (now - this.lastMoveTime < this.moveDelay) return;

                    if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
                        this.player.move(0, -1);
                        this.lastMoveTime = now;
                        e.preventDefault();
                    } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
                        this.player.move(0, 1);
                        this.lastMoveTime = now;
                        e.preventDefault();
                    } else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                        this.player.move(-1, 0);
                        this.lastMoveTime = now;
                        e.preventDefault();
                    } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                        this.player.move(1, 0);
                        this.lastMoveTime = now;
                        e.preventDefault();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                });
            }

            update() {
                if (this.gameOver) return;

                this.player.update();
                this.lanes.forEach(lane => lane.update());
                this.checkCollisions();

                // Generate new lanes as player progresses
                if (this.player.y < 5) {
                    this.shiftLanes();
                }
            }

            shiftLanes() {
                // Remove bottom lane
                this.lanes.pop();

                // Add new lane at top
                const rand = Math.random();
                let type;
                if (rand < 0.3) {
                    type = LANE_TYPES.GRASS;
                } else if (rand < 0.65) {
                    type = LANE_TYPES.ROAD;
                } else {
                    type = LANE_TYPES.RIVER;
                }

                this.lanes.unshift(new Lane(0, type));

                // Adjust all lane positions
                this.lanes.forEach((lane, index) => {
                    lane.y = index;
                });

                // Move player down one row
                this.player.y += 1;
                this.player.targetY += 1;
            }

            checkCollisions() {
                const pos = this.player.getPosition();
                const currentLane = this.lanes[pos.y];

                if (currentLane.type === LANE_TYPES.ROAD) {
                    // Check car collision
                    for (let obstacle of currentLane.obstacles) {
                        if (obstacle.collidesWith(pos.x, pos.y)) {
                            this.endGame();
                            return;
                        }
                    }
                } else if (currentLane.type === LANE_TYPES.RIVER) {
                    // Check if on a log
                    let onLog = false;
                    for (let obstacle of currentLane.obstacles) {
                        if (obstacle.collidesWith(pos.x, pos.y)) {
                            onLog = true;
                            // Move player with log
                            if (!this.player.moving) {
                                this.player.x += obstacle.speed;
                                this.player.targetX = this.player.x;

                                // Check if moved off screen
                                if (this.player.x < 0 || this.player.x >= GRID_COLS) {
                                    this.endGame();
                                    return;
                                }
                            }
                            break;
                        }
                    }

                    if (!onLog && !this.player.moving) {
                        this.endGame();
                    }
                }
            }

            endGame() {
                this.gameOver = true;
                document.getElementById('finalScore').textContent = `Score: ${this.score}`;
                document.getElementById('gameOver').style.display = 'block';
            }

            restart() {
                this.gameOver = false;
                this.maxScore = Math.max(this.maxScore, this.score);
                this.score = 0;
                this.player.reset();
                this.init();
                document.getElementById('gameOver').style.display = 'none';
            }

            draw() {
                // Clear canvas
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // Draw lanes
                this.lanes.forEach(lane => lane.draw());

                // Draw player
                this.player.draw();

                // Update score display
                document.getElementById('score').textContent =
                    `Score: ${this.score} | Best: ${this.maxScore}`;
            }

            gameLoop() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
        }

        // Start the game
        const game = new Game();
    </script>
</body>
</html>
